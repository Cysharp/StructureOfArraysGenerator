using Microsoft.CodeAnalysis;
using System.Text;

namespace StructureOfArraysGenerator;

[Generator(LanguageNames.CSharp)]
public partial class Generator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(static context =>
        {
            context.AddSource("StructureOfArraysGeneratorAttributes.cs", """
namespace StructureOfArraysGenerator;

using System;

internal interface IMultiArray<T>
{
    int Length { get; }
    ReadOnlySpan<byte> GetRawSpan();
#if NET7_0_OR_GREATER
    static abstract int GetByteSize(int length);
    static abstract T Create(int length, ArraySegment<byte> arrayOffset);
#endif
}

internal interface IMultiArrayList<T>
{
    int Length { get; }
    ReadOnlySpan<byte> GetRawSpan();
#if NET7_0_OR_GREATER
    static abstract T Create(int length, ArraySegment<byte> arrayOffset);
#endif
}

[AttributeUsage(AttributeTargets.Struct, AllowMultiple = false, Inherited = false)]
internal sealed class MultiArrayAttribute : Attribute
{
    public Type Type { get; }

    public MultiArrayAttribute2(Type type, bool includeProperty = false)
    {
        this.Type = type;
    }
}

[AttributeUsage(AttributeTargets.Class, AllowMultiple = false, Inherited = false)]
internal sealed class MultiArrayListAttribute : Attribute
{
}
""");
        });

        var source = context.SyntaxProvider.ForAttributeWithMetadataName(
                 "StructureOfArraysGenerator.MultiArrayAttribute",
                 static (node, token) => true,
                 static (context, token) => context);

        context.RegisterSourceOutput(source, Emit);

        // TODO: Emit List and verify require MultiArrayAttribute
    }

    static void Emit(SourceProductionContext context, GeneratorAttributeSyntaxContext source)
    {
        var elementType = (INamedTypeSymbol)source.Attributes[0].ConstructorArguments[0].Value!;
        var includeProperty = (bool)source.Attributes[0].ConstructorArguments[1].Value!;

        var members = elementType.GetMembers()
            .Where(x =>
            {
                if (!(x.DeclaredAccessibility is Accessibility.Public or Accessibility.Internal))
                {
                    return false;
                }

                if (x is IFieldSymbol) return true;

                if (includeProperty && x is IPropertySymbol)
                {
                    return true;
                }

                return false;
            })
            .Select(x => new MetaMember(x))
            .ToArray();

        // Verify.

        // All target members should be unamanged
        if (!members.All(x => x.MemberType.IsUnmanagedType))
        {
            // TODO: dianogstics error.
        }

        // TODO: empty struct
        // TODO: partial
        // TODO: readonly


        // Gen.

        var arrayType = source.TargetSymbol.Name;


        // Finish cod format.

        var code = BuildMultiArray(source.TargetSymbol, elementType, members);

        var fullType = source.TargetSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)
            .Replace("global::", "")
            .Replace("<", "_")
            .Replace(">", "_");

        var sb = new StringBuilder();

        sb.AppendLine(@"
// <auto-generated/>
#nullable enable
#pragma warning disable CS0108 // hides inherited member
#pragma warning disable CS0162 // Unreachable code
#pragma warning disable CS0164 // This label has not been referenced
#pragma warning disable CS0219 // Variable assigned but never used
#pragma warning disable CS8600 // Converting null literal or possible null value to non-nullable type.
#pragma warning disable CS8601 // Possible null reference assignment
#pragma warning disable CS8602
#pragma warning disable CS8604 // Possible null reference argument for parameter
#pragma warning disable CS8619
#pragma warning disable CS8620
#pragma warning disable CS8631 // The type cannot be used as type parameter in the generic type or method
#pragma warning disable CS8765 // Nullability of type of parameter
#pragma warning disable CS9074 // The 'scoped' modifier of parameter doesn't match overridden or implemented member
#pragma warning disable CA1050 // Declare types in namespaces.

using System;
");

        var ns = source.TargetSymbol.ContainingNamespace;
        if (!ns.IsGlobalNamespace)
        {
            sb.AppendLine($"namespace {ns} {{");
        }
        sb.AppendLine();

        sb.AppendLine(code);

        if (!ns.IsGlobalNamespace)
        {
            sb.AppendLine($"}}");
        }

        var sourceCode = sb.ToString();

        context.AddSource($"{fullType}.g.cs", sourceCode);
    }

    // helper for code generator

    static string ForEachLine<T>(string indent, T[] values, Func<T, string> lineSelector)
    {
        return string.Join(Environment.NewLine, values.Select(x => indent + lineSelector(x)));
    }

    static string ForLine(string indent, int begin, int end, Func<int, string> lineSelector)
    {
        return string.Join(Environment.NewLine, Enumerable.Range(begin, end - begin).Select(x => indent + lineSelector(x)));
    }

    static string BuildMultiArray(ISymbol targetType, INamedTypeSymbol elementType, MetaMember[] members)
    {
        var targetTypeName = targetType.Name;
        var elementTypeName = elementType.Name;

        var code = $$"""
[System.Runtime.InteropServices.StructLayout(System.Runtime.InteropServices.LayoutKind.Auto)]
partial struct {{targetTypeName}} : global::StructureOfArraysGenerator.IMultiArray<{{targetTypeName}}>
{
    readonly byte[] __value;
    readonly int __length;
    readonly int __byteSize;
{{ForEachLine("    ", members, x => $"readonly int __byteOffset{x.Name};")}}

    public int Length => __length;
{{ForEachLine("    ", members, x => $"public Span<{x.MemberTypeFullName}> {x.Name} => MemoryMarshal.CreateSpan(ref Unsafe.As<byte, {x.MemberTypeFullName}>(ref Unsafe.Add(ref MemoryMarshal.GetArrayDataReference(__value), __byteOffset{x.Name})), __length);")}}

    public static int GetByteSize(int length)
    {
        return 0
{{ForEachLine("             ", members, x => $"+ Unsafe.SizeOf<{x.MemberTypeFullName}>() * length")}}
             ;
    }

    public static {{targetTypeName}} Create(int length, ArraySegment<byte> arrayOffset)
    {
        return new {{targetTypeName}}(length, arrayOffset);
    }

    public {{targetTypeName}}(int length)
    {
        this.__byteOffset{{members[0].Name}} = 0;
{{ForLine("        ", 1, members.Length, x => $"this.__byteOffset{members[x].Name} = __byteOffset{members[x - 1].Name} + (Unsafe.SizeOf<{members[x - 1].MemberTypeFullName}>() * length);")}}
        this.__byteSize = __byteOffset{{members[members.Length - 1].Name}} + (Unsafe.SizeOf<{{members[members.Length - 1].MemberTypeFullName}}>() * length);
        this.__value = new byte[__byteSize];
        this.__length = length;
    }

    public {{targetTypeName}}(int length, ArraySegment<byte> arrayOffset)
    {
        this.__byteOffsetX = arrayOffset.Offset;
{{ForLine("        ", 1, members.Length, x => $"this.__byteOffset{members[x].Name} = __byteOffset{members[x - 1].Name} + (Unsafe.SizeOf<{members[x - 1].MemberTypeFullName}>() * length);")}}
        this.__byteSize = __byteOffset{{members[members.Length - 1].Name}} + (Unsafe.SizeOf<{{members[members.Length - 1].MemberTypeFullName}}>() * length);
        this.__value = arrayOffset.Array!;
        this.__length = length;
    }

    public {{elementTypeName}} this[int index]
    {
        get
        {
{{ForEachLine("            ", members, x => $"ref var __{x.Name} = ref Unsafe.Add(ref Unsafe.As<byte, {x.MemberTypeFullName}>(ref Unsafe.Add(ref MemoryMarshal.GetArrayDataReference(__value), __byteOffset{x.Name})), index);")}}
            return new {{elementTypeName}}
            {
{{ForEachLine("                ", members, x => $"{x.Name} = __{x.Name},")}}
            };
        }
        set
        {
{{ForEachLine("            ", members, x => $"Unsafe.Add(ref Unsafe.As<byte, {x.MemberTypeFullName}>(ref Unsafe.Add(ref MemoryMarshal.GetArrayDataReference(__value), __byteOffset{x.Name})), index) = value.{x.Name};")}}
        }
    }

    public ReadOnlySpan<byte> GetRawSpan() => __value.AsSpan(__byteOffsetX, __byteSize);

    public bool SequenceEqual({{targetTypeName}} other)
    {
        return GetRawSpan().SequenceEqual(other.GetRawSpan());
    }
}
""";

        return code;
    }
}


public class MetaMember
{
    public ITypeSymbol MemberType { get; }
    public string MemberTypeFullName { get; set; }
    public string Name { get; }
    public bool IsField { get; }

    public MetaMember(ISymbol symbol)
    {
        this.Name = symbol.Name;
        if (symbol is IFieldSymbol f)
        {
            this.MemberType = f.Type;
            this.IsField = true;
        }
        else if (symbol is IPropertySymbol p)
        {
            this.MemberType = p.Type;
            this.IsField = false;
        }
        else
        {
            throw new InvalidOperationException("Symbol type is invalid. " + symbol.GetType().FullName);
        }
        this.MemberTypeFullName = this.MemberType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
    }
}

public static class DiagnosticDescriptors
{
    const string Category = "SampleGenerator";

    public static readonly DiagnosticDescriptor ExistsOverrideToString = new(
        id: "SAMPLE001",
        title: "ToString override",
        messageFormat: "The GenerateToString class '{0}' has ToString override but it is not allowed.",
        category: Category,
        defaultSeverity: DiagnosticSeverity.Error,
        isEnabledByDefault: true);
}